;
;  SCAM/PASTA. Make random linked graphs to test the garbage collector.
;
;  Copyright © 2011 James B. Moen.
;
;  This  program is free  software: you  can redistribute  it and/or  modify it
;  under the terms  of the GNU General Public License as  published by the Free
;  Software Foundation,  either version 3 of  the License, or  (at your option)
;  any later version.
;
;  This program is distributed in the  hope that it will be useful, but WITHOUT
;  ANY  WARRANTY;  without even  the  implied  warranty  of MERCHANTABILITY  or
;  FITNESS FOR  A PARTICULAR PURPOSE.  See  the GNU General  Public License for
;  more details.
;
;  You should have received a copy of the GNU General Public License along with
;  this program.  If not, see <http://www.gnu.org/licenses/>.
;

;  PASTA generates random "spaghetti" graphs forever, or until you stop it. The
;  graphs may be arbitrarily large, and may contain cycles.  PASTA uses Orson's
;  garbage collector LIB.DUMP to recover the memory used by subgraphs which get
;  unlinked during generation. If PASTA runs forever then the garbage collector
;  might work correctly. If PASTA crashes, then the garbage collector has bugs.

;  PASTA. Create and write lists of WIDTH random spaghetti graphs, forever. The
;  graphs are generated by repeatedly picking a random ACTION and then carrying
;  it out. There are four possible ACTIONs on the roots of the graph:
;
;    0  Choose a root at random and delete it (replace it by NIL).
;    1  Choose two roots at random and replace one by the other.
;    2  Choose a root at random and replace it by a new vertex (a CONS).
;    3  Choose a root at random and MUTATE one of its subgraphs (see below).

(define width 4)

(define pasta
 (λ ()
  (let
   ((roots (makeVector width)))
   (loop
    (λ ()
     (objWrite roots)
     (let
      ((action (pick 4)))
      (if
       (intEq action 0)
       (setElement roots (pick width) nil)
       (if
        (intEq action 1)
        (setElement roots (pick width) (getElement roots (pick width)))
        (if
         (intEq action 2)
         (setElement roots (pick width) (cons nil nil))
         (if
          (intEq action 3)
          (mutate (getElement roots (pick width)) roots)
          (throw `error)))))))))) )

;  MUTATE. Follow a randomly chosen path through GRAPH. At the end of the path,
;  replace one of GRAPH's branches by a graph in ROOTS. We repeatedly choose an
;  ACTION at random and carry it out. Possible ACTIONs are:
;
;    0  Follow the left branch (CAR).
;    1  Follow the right branch (CDR).
;    2  Replace the left branch by a randomly chosen graph from ROOTS.
;    3  Replace the right branch by a randomly chosen graph from ROOTS.

(define mutate
 (λ (graph roots)
  (or
   (isNil graph)
   (let
    ((action (pick 4)))
    (if
     (intEq action 0)
     (if
      (isNil (car graph))
      (setCar graph (getElement roots (pick width)))
      (mutate (car graph) roots))
     (if
      (intEq action 1)
      (if
       (isNil (cdr graph))
       (setCdr graph (getElement roots (pick width)))
       (mutate (cdr graph) roots))
      (if
       (intEq action 2)
       (setCdr graph (getElement roots (pick width)))
       (if
        (intEq action 3)
        (setCdr graph (getElement roots (pick width)))
        (throw `error)))))))) )

;  LOOP. Repeatedly call BODY, which takes no arguments, in an infinite loop.

(define loop
 (λ (body)
  (body)
  (loop body)) )

;  MAKE VECTOR. Return a list of NILs whose length is COUNT.

(define makeVector
 (λ (count)
  (if
   (intEq count 0)
   nil
   (cons nil (makeVector (intSub count 1))))) )

;  GET ELEMENT. Return the INDEXth element of the list VECTOR.

(define getElement
 (λ (vector index)
  (if
   (intEq index 0)
   (car vector)
   (getElement (cdr vector) (intSub index 1)))) )

;  SET ELEMENT. Set the INDEXth element of the list VECTOR to ELEMENT.

(define setElement
 (λ (vector index element)
  (if
   (intEq index 0)
   (setCar vector element)
   (setElement (cdr vector) (intSub index 1) element))) )

;  PICK. Return a random integer in the range 0 to RANGE − 1. We use the random
;  number generator described in:
;
;  Charles Herring & Julian I. Palmore. "Random Number Generators are Chaotic."
;  ACM SIGPLAN Notices. Volume 24, Number 11, November 1989. Pages 76–79.
;
;  Actually we use only the upper 16 bits of terms in the sequence, because the
;  low-order bits aren't very random.

(define state 7734)        ;  Seed, which must be between 1 and M − 1.
(define A     16807)       ;  7⁵.
(define D     65536)       ;  2¹⁶.
(define M     2147483647)  ;  2³¹ − 1.

(define pick
 (λ (range)
  (set state (intMod (intMul A state) M))
  (intMod (intDiv (abs state) D) range)) )

;  ABS. Return the absolute value of NUMBER.

(define abs
 (λ (number)
  (if
   (intLt number 0)
   (intNeg number)
   number)) )
